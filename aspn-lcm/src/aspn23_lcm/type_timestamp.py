"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

"""
This code is generated via https://git.aspn.us/pntos/firehose/-/blob/main/firehose/backends/aspn/aspn_yaml_to_lcm.py
DO NOT hand edit code.  Make any changes required using the firehose repo instead
"""

from io import BytesIO
import struct

class type_timestamp(object):
    """
    Whole number nanoseconds elapsed since timestamp's zero epoch. If negative, whole number nanoseconds
    until timestamp's zero epoch. The zero epoch definition is based on the timing source used by the
    message provider. The timing source used by the message provider is defined by the
    `timestamp_clock_id` included in the `type_metadataheader` as part of the metadata. Additionally,
    the timestamp's digits of precision are included in the `type_metadataheader` as part of the
    metadata, which may be useful if an implementation is converting the timestamp to another type
    internally.
    If needed, the time elapsed in seconds is equal to elapsed_nsec * 1e-9.
    """

    __slots__ = ["icd_type_timestamp", "elapsed_nsec"]

    __typenames__ = ["int8_t", "int64_t"]

    __dimensions__ = [None, None]

    def __init__(self):
        self.icd_type_timestamp = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.elapsed_nsec = 0
        """
        Description: Whole number nanoseconds elapsed since timestamp's zero epoch. If negative, whole
        number nanoseconds until timestamp's zero epoch.
        Units: nanoseconds
        LCM Type: int64_t
        """


    def encode(self):
        buf = BytesIO()
        buf.write(type_timestamp._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">bq", self.icd_type_timestamp, self.elapsed_nsec))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_timestamp._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_timestamp._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_timestamp()
        self.icd_type_timestamp, self.elapsed_nsec = struct.unpack(">bq", buf.read(9))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_timestamp in parents: return 0
        tmphash = (0xd8271c75bd496a80) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_timestamp._packed_fingerprint is None:
            type_timestamp._packed_fingerprint = struct.pack(">Q", type_timestamp._get_hash_recursive([]))
        return type_timestamp._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", type_timestamp._get_packed_fingerprint())[0]

