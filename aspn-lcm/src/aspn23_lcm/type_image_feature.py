"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct


class type_image_feature(object):
    """Image feature characteristics"""

    __slots__ = [
        "icd_type_image_feature",
        "response",
        "orientation",
        "size",
        "class_id",
        "octave",
        "descriptor_size",
        "descriptor",
    ]

    __typenames__ = [
        "int8_t",
        "double",
        "double",
        "double",
        "int32_t",
        "int32_t",
        "int32_t",
        "int16_t",
    ]

    __dimensions__ = [None, None, None, None, None, None, None, ["descriptor_size"]]

    def __init__(self):
        self.icd_type_image_feature = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.response = 0.0
        """
        Description: Value representing the magnitude of the response of the keypoint detection algorithm used to locate this keypoint in the image
        Units: none
        LCM Type: double
        """

        self.orientation = 0.0
        """
        Description: Value representing the orientation of the detected keypoint, as measured relative to the image coordinate system (radians, clockwise). Metadata flag determines if this field is calculated by the current keypoint detector
        Units: rad
        LCM Type: double
        """

        self.size = 0.0
        """
        Description: Effective size (pixels) of the detected keypoint. This field takes into consideration the octave and kernel used to localize the keypoint, and normalizes to the original size of the image
        Units: pixels
        LCM Type: double
        """

        self.class_id = 0
        """
        Description: ID that ties the detected keypoint to a class or group of keypoints
        Units: none
        LCM Type: int32_t
        """

        self.octave = 0
        """
        Description: Octave or pyramid layer from which the detected keypoint was extracted
        Units: none
        LCM Type: int32_t
        """

        self.descriptor_size = 0
        """
        Description: Size of the descriptor in bytes
        Units: none
        LCM Type: int32_t
        """

        self.descriptor = []
        """
        Description: Feature descriptor
        Units: none
        LCM Type: int16_t[descriptor_size]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(type_image_feature._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(
            struct.pack(
                ">bdddiii",
                self.icd_type_image_feature,
                self.response,
                self.orientation,
                self.size,
                self.class_id,
                self.octave,
                self.descriptor_size,
            )
        )
        buf.write(
            struct.pack(
                ">%dh" % self.descriptor_size, *self.descriptor[: self.descriptor_size]
            )
        )

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_image_feature._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_image_feature._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_image_feature()
        (
            self.icd_type_image_feature,
            self.response,
            self.orientation,
            self.size,
            self.class_id,
            self.octave,
            self.descriptor_size,
        ) = struct.unpack(">bdddiii", buf.read(37))
        self.descriptor = struct.unpack(
            ">%dh" % self.descriptor_size, buf.read(self.descriptor_size * 2)
        )
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_image_feature in parents:
            return 0
        tmphash = (0x961ED1E790449286) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_image_feature._packed_fingerprint is None:
            type_image_feature._packed_fingerprint = struct.pack(
                ">Q", type_image_feature._get_hash_recursive([])
            )
        return type_image_feature._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", type_image_feature._get_packed_fingerprint())[0]
