"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class type_direction_2d_to_point(object):
    """
    2D direction to or from a point as defined by the reference enum. Information
    about the remote point (its position and/or correspondence with previous or
    future appearances of this same point) may be determined using remote_point.
    """

    __slots__ = [
        "icd_type_direction_2d_to_point",
        "remote_point",
        "reference",
        "obs",
        "variance",
        "has_observation_characteristics",
        "observation_characteristics",
        "error_model",
        "num_error_model_params",
        "error_model_params",
        "num_integrity",
        "integrity",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_remote_point",
        "int8_t",
        "double",
        "double",
        "boolean",
        "aspn23_lcm.type_image_feature",
        "int8_t",
        "int32_t",
        "double",
        "int16_t",
        "aspn23_lcm.type_integrity",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        ["num_error_model_params"],
        None,
        ["num_integrity"],
    ]

    REFERENCE_NE_TO = 0
    """ Angle between the sensor's local level N-axis and the vector from the sensor to the point projected onto the sensor's local level North-East plane. Positive angle is defined as a rotation towards the E-axis. See also NED coordinate frame definition for N, E, and D definitions. A figure depicting the angle definition is included in the conventions documentation. """
    REFERENCE_NE_FROM = 1
    """ Angle between the point's local level N-axis and the vector from the point to the sensor projected onto the point's local level North-East plane. Positive angle is defined as a rotation towards the E-axis. The significant difference between NE_TO and NE_FROM is where the NED frame originates (NE_FROM has its origin located at the point's location). See also NED coordinate frame definition for N, E, and D definitions. A figure depicting the angle definition is included in the conventions documentation. """
    REFERENCE_ELEVATION = 2
    """ Angle between the sensor's local level North-East plane and the vector from the sensor to the point. Positive angle is defined as a rotation towards the negative D-axis of the NED frame. See also NED coordinate frame definition for N, E, and D definitions. A figure depicting the angle definition is included in the conventions documentation. """
    REFERENCE_SENSOR = 3
    """ Angle between the sensor's x-axis and the vector from the sensor to the point projected onto the sensor frame x-y plane. Positive angle is defined as a rotation towards the y-axis. Sensor frame is defined in mounting. A figure depicting the angle definition is included in the conventions documentation. """
    ERROR_MODEL_NONE = 0
    """ No additional error model provided (num_error_model_params = 0). """

    def __init__(self):
        self.icd_type_direction_2d_to_point = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.remote_point = aspn23_lcm.type_remote_point()
        """
        Description: Position and/or correspondence information about the remote point
        Units: various
        LCM Type: aspn23_lcm.type_remote_point
        """

        self.reference = 0
        """
        Specifies measurement reference.
        LCM Type: int8_t
        """

        self.obs = 0.0
        """
        Description: Observations as specified in the reference enum
        Units: rad
        LCM Type: double
        """

        self.variance = 0.0
        """
        Description: Measurement error variance
        Units: rad^2
        LCM Type: double
        """

        self.has_observation_characteristics = False
        """
        Description: Switch for whether observation_characteristics is valid or not
        Units: none
        LCM Type: boolean
        """

        self.observation_characteristics = aspn23_lcm.type_image_feature()
        """
        Description: Image feature characteristics
        Units: various
        LCM Type: aspn23_lcm.type_image_feature
        """

        self.error_model = 0
        """
        Defines an optional error model for other than zero-mean, additive, white Gaussian noise (AWGN).
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model
        Units: various
        LCM Type: double[num_error_model_params]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity. Includes the integrity method used and an integrity value (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity > 1 is to report multiple integrity values based on multiple integrity methods
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(type_direction_2d_to_point._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_type_direction_2d_to_point))
        assert (
            self.remote_point._get_packed_fingerprint()
            == aspn23_lcm.type_remote_point._get_packed_fingerprint()
        )
        self.remote_point._encode_one(buf)
        buf.write(
            struct.pack(
                ">bddb",
                self.reference,
                self.obs,
                self.variance,
                self.has_observation_characteristics,
            )
        )
        assert (
            self.observation_characteristics._get_packed_fingerprint()
            == aspn23_lcm.type_image_feature._get_packed_fingerprint()
        )
        self.observation_characteristics._encode_one(buf)
        buf.write(struct.pack(">bi", self.error_model, self.num_error_model_params))
        buf.write(
            struct.pack(
                ">%dd" % self.num_error_model_params,
                *self.error_model_params[: self.num_error_model_params]
            )
        )
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert (
                self.integrity[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_integrity._get_packed_fingerprint()
            )
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_direction_2d_to_point._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_direction_2d_to_point._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_direction_2d_to_point()
        self.icd_type_direction_2d_to_point = struct.unpack(">b", buf.read(1))[0]
        self.remote_point = aspn23_lcm.type_remote_point._decode_one(buf)
        self.reference, self.obs, self.variance = struct.unpack(">bdd", buf.read(17))
        self.has_observation_characteristics = bool(struct.unpack("b", buf.read(1))[0])
        self.observation_characteristics = aspn23_lcm.type_image_feature._decode_one(
            buf
        )
        self.error_model, self.num_error_model_params = struct.unpack(
            ">bi", buf.read(5)
        )
        self.error_model_params = struct.unpack(
            ">%dd" % self.num_error_model_params,
            buf.read(self.num_error_model_params * 8),
        )
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_direction_2d_to_point in parents:
            return 0
        newparents = parents + [type_direction_2d_to_point]
        tmphash = (
            0x802C92D942A22E45
            + aspn23_lcm.type_remote_point._get_hash_recursive(newparents)
            + aspn23_lcm.type_image_feature._get_hash_recursive(newparents)
            + aspn23_lcm.type_integrity._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_direction_2d_to_point._packed_fingerprint is None:
            type_direction_2d_to_point._packed_fingerprint = struct.pack(
                ">Q", type_direction_2d_to_point._get_hash_recursive([])
            )
        return type_direction_2d_to_point._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(
            ">Q", type_direction_2d_to_point._get_packed_fingerprint()
        )[0]
