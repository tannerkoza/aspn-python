"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class measurement_position_attitude(object):
    """
    Position and attitude, also known as pose. Position is relative to a
    user-defined reference frame. Attitude expressed as a quaternion, a four element
    vector representation, the elements of which are functions of the orientation of
    the vector and the magnitude of the rotation.
    """

    __slots__ = [
        "icd_measurement_position_attitude",
        "header",
        "time_of_validity",
        "reference_frame",
        "p1",
        "p2",
        "p3",
        "quaternion",
        "covariance",
        "error_model",
        "num_error_model_params",
        "error_model_params",
        "num_integrity",
        "integrity",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_header",
        "aspn23_lcm.type_timestamp",
        "int8_t",
        "double",
        "double",
        "double",
        "double",
        "double",
        "int8_t",
        "int32_t",
        "double",
        "int16_t",
        "aspn23_lcm.type_integrity",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        [4],
        [6, 6],
        None,
        None,
        ["num_error_model_params"],
        None,
        ["num_integrity"],
    ]

    REFERENCE_FRAME_ECI = 0
    """ Sensor position and attitude relative to the earth-centered, inertial (ECi) frame. Position is expressed where p1, p2, and p3 are the x, y, and z components of ECI position in meters, respectively. Attitude is expressed as a four-element quaternion. Error covariance is given using x-axis position error component (meters), y-axis position error component (meters), z-axis position error component (meters), tilt error about the x-axis (rad), tilt error about the y-axis (rad), and tilt error about the z-axis (rad). See also ECi coordinate frame definition for x, y, and z definitions. """
    REFERENCE_FRAME_GEODETIC = 1
    """ Sensor position, and attitude relative to the WGS-84 reference. Position is expressed where p1 is the geodetic latitude in radians, p2 is the longitude in radians, and p3 is the geodetic altitude (or height above the WGS-84 ellipsoid) in meters. Attitude is the sensor frame rotation relative to the local level frame expressed as a four-element quaternion. Error covariance is given using north-south position error (meters), east-west position error (meters), geodetic altitude error (meters), tilt error about the north axis (rad), tilt error about the east axis (rad), and tilt error about the down axis (rad). """
    ERROR_MODEL_NONE = 0
    """ No additional error model provided (num_error_model_params = 0). """

    def __init__(self):
        self.icd_measurement_position_attitude = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.reference_frame = 0
        """
        Defines measurement reference.
        LCM Type: int8_t
        """

        self.p1 = 0.0
        """
        Description: First position term as defined in enum
        Units: rad
        LCM Type: double
        """

        self.p2 = 0.0
        """
        Description: First position term as defined in enum
        Units: rad
        LCM Type: double
        """

        self.p3 = 0.0
        """
        Description: First position term as defined in enum
        Units: m
        LCM Type: double
        """

        self.quaternion = [0.0 for dim0 in range(4)]
        """
        Description: Four element quaternion, q = [a, b, c, d], where a = cos(phi/2), b = (phi_x/phi)*sin(phi/2), c = (phi_y/phi)*sin(phi/2), and d = (phi_z/phi)*sin(phi/2). In this description, the vector [phi_x, phi_y, phi_z] represents the rotation vector that describes the frame rotation to be applied to the "reference" frame (ECI, ECEF, or NED) to rotate it into the axes that describe the measured attitude, and the value phi is the magnitude of the [phi_x, phi_y, phi_z] vector. See "conventions" documentation for more detailed information
        Units: none
        LCM Type: double[4]
        """

        self.covariance = [[0.0 for dim1 in range(6)] for dim0 in range(6)]
        """
        Description: Measurement error variance or covariance depending on measurement dimension
        Units: various
        LCM Type: double[6][6]
        """

        self.error_model = 0
        """
        Defines an optional error model for other than zero-mean, additive, white Gaussian noise (AWGN).
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model
        Units: various
        LCM Type: double[num_error_model_params]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity. Includes the integrity method used and an integrity value (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity > 1 is to report multiple integrity values based on multiple integrity methods
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(measurement_position_attitude._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_position_attitude))
        assert (
            self.header._get_packed_fingerprint()
            == aspn23_lcm.type_header._get_packed_fingerprint()
        )
        self.header._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        buf.write(struct.pack(">bddd", self.reference_frame, self.p1, self.p2, self.p3))
        buf.write(struct.pack(">4d", *self.quaternion[:4]))
        for i0 in range(6):
            buf.write(struct.pack(">6d", *self.covariance[i0][:6]))
        buf.write(struct.pack(">bi", self.error_model, self.num_error_model_params))
        buf.write(
            struct.pack(
                ">%dd" % self.num_error_model_params,
                *self.error_model_params[: self.num_error_model_params]
            )
        )
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert (
                self.integrity[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_integrity._get_packed_fingerprint()
            )
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_position_attitude._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_position_attitude._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_position_attitude()
        self.icd_measurement_position_attitude = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.reference_frame, self.p1, self.p2, self.p3 = struct.unpack(
            ">bddd", buf.read(25)
        )
        self.quaternion = struct.unpack(">4d", buf.read(32))
        self.covariance = []
        for i0 in range(6):
            self.covariance.append(struct.unpack(">6d", buf.read(48)))
        self.error_model, self.num_error_model_params = struct.unpack(
            ">bi", buf.read(5)
        )
        self.error_model_params = struct.unpack(
            ">%dd" % self.num_error_model_params,
            buf.read(self.num_error_model_params * 8),
        )
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_position_attitude in parents:
            return 0
        newparents = parents + [measurement_position_attitude]
        tmphash = (
            0x20659A8EFF6A2801
            + aspn23_lcm.type_header._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_integrity._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_position_attitude._packed_fingerprint is None:
            measurement_position_attitude._packed_fingerprint = struct.pack(
                ">Q", measurement_position_attitude._get_hash_recursive([])
            )
        return measurement_position_attitude._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(
            ">Q", measurement_position_attitude._get_packed_fingerprint()
        )[0]
