"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

"""
This code is generated via https://git.aspn.us/pntos/firehose/-/blob/main/firehose/backends/aspn/aspn_yaml_to_lcm.py
DO NOT hand edit code.  Make any changes required using the firehose repo instead
"""

from io import BytesIO
import struct

class type_remote_point(object):
    """
    ASPN custom type representing a point. This includes optional information
    (indicated by included_terms) for the position and a correspondence ID for the
    point.
    """

    __slots__ = ["icd_type_remote_point", "included_terms", "id", "position_reference_frame", "position1", "position2", "position3", "num_position_components", "position_covariance"]

    __typenames__ = ["int8_t", "int16_t", "int64_t", "int8_t", "double", "double", "double", "int16_t", "double"]

    __dimensions__ = [None, None, None, None, None, None, None, None, ["num_position_components", "num_position_components"]]

    POSITION_REFERENCE_FRAME_NONE = 0
    """
    No reference frame. This is only valid if position is not included
    (included_terms is 0 or 1).
    """
    POSITION_REFERENCE_FRAME_GEODETIC = 1
    """
    Point position relative to the WGS-84 reference expressed using position1 as geodetic latitude
    in radians, position2 as longitude in radians, and position3 as geodetic altitude (or height
    above the WGS-84 ellipsoid) in meters. Each term is optional.
    position_covariance is given using north-south position error in meters (an expression of
    geodetic latitude error), east-west position error in meters (an expression of longitude
    error), and geodetic altitude error in meters. In the case of nulled position components, the
    corresponding error covariance terms are omitted.
    """

    def __init__(self):
        self.icd_type_remote_point = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.included_terms = 0
        """
        Description: Indicates which information is included about the point
        0 = no information included (unknown point)
        1 = id included (corresponded point)
        2 = position included (known point)
        3 = id and position included
        Units: none
        LCM Type: int16_t
        """

        self.id = 0
        """
        Description: Unique identification number assigned by the sensor. Points that have the same id
        from a sensor are multiple instances of the same point as determined by a sensor's point
        correspondence.
        Units: none
        LCM Type: int64_t
        """

        self.position_reference_frame = 0
        """
        Defines position reference.
        LCM Type: int8_t
        """

        self.position1 = 0.0
        """
        Description: First position term as defined in position_reference_frame.
        Units: various
        LCM Type: double
        """

        self.position2 = 0.0
        """
        Description: Second position term as defined in position_reference_frame.
        Units: various
        LCM Type: double
        """

        self.position3 = 0.0
        """
        Description: Third position term as defined in position_reference_frame.
        Units: various
        LCM Type: double
        """

        self.num_position_components = 0
        """
        Description: Dimension of position provided.
        Units: none
        LCM Type: int16_t
        """

        self.position_covariance = []
        """
        Description: Position error covariance (or variance depending on num_position_components) as
        defined in position_reference_frame.
        Units: m^2
        LCM Type: double[num_position_components][num_position_components]
        """


    def encode(self):
        buf = BytesIO()
        buf.write(type_remote_point._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">bhqbdddh", self.icd_type_remote_point, self.included_terms, self.id, self.position_reference_frame, self.position1, self.position2, self.position3, self.num_position_components))
        for i0 in range(self.num_position_components):
            buf.write(struct.pack('>%dd' % self.num_position_components, *self.position_covariance[i0][:self.num_position_components]))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_remote_point._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_remote_point._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_remote_point()
        self.icd_type_remote_point, self.included_terms, self.id, self.position_reference_frame, self.position1, self.position2, self.position3, self.num_position_components = struct.unpack(">bhqbdddh", buf.read(38))
        self.position_covariance = []
        for i0 in range(self.num_position_components):
            self.position_covariance.append(struct.unpack('>%dd' % self.num_position_components, buf.read(self.num_position_components * 8)))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_remote_point in parents: return 0
        tmphash = (0x985107f99d375eb5) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_remote_point._packed_fingerprint is None:
            type_remote_point._packed_fingerprint = struct.pack(">Q", type_remote_point._get_hash_recursive([]))
        return type_remote_point._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", type_remote_point._get_packed_fingerprint())[0]

