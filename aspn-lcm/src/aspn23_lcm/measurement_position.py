"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class measurement_position(object):
    """
    One, two, or three dimensional position relative to a user-defined reference
    frame.
    """

    __slots__ = [
        "icd_measurement_position",
        "header",
        "time_of_validity",
        "reference_frame",
        "term1",
        "term2",
        "term3",
        "num_meas",
        "covariance",
        "error_model",
        "num_error_model_params",
        "error_model_params",
        "num_integrity",
        "integrity",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_header",
        "aspn23_lcm.type_timestamp",
        "int8_t",
        "double",
        "double",
        "double",
        "int16_t",
        "double",
        "int8_t",
        "int32_t",
        "double",
        "int16_t",
        "aspn23_lcm.type_integrity",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        ["num_meas", "num_meas"],
        None,
        None,
        ["num_error_model_params"],
        None,
        ["num_integrity"],
    ]

    REFERENCE_FRAME_ECI = 0
    """ Sensor position relative to the earth-centered, inertial (ECi) frame expressed where term1, term2, and term3 are the x, y, and z components of ECI position in meters, respectively. Each term is optional. Error covariance is given using x-axis position error component (meters), y-axis position error component (meters), and z-axis position error component (meters). In the case of nulled position components, the corresponding error covariance terms are omitted. See also ECi coordinate frame definition for x, y, and z definitions. """
    REFERENCE_FRAME_GEODETIC = 1
    """ Sensor position relative to the WGS-84 reference expressed using term1 as geodetic latitude in radians, term2 as longitude in radians, and term3 as geodetic altitude (or height above the WGS-84 ellipsoid) in meters. Each term is optional. Error covariance is given using north-south position error in meters (an expression of geodetic latitude error), east-west position error in meters (an expression of longitude error in meters), and geodetic altitude error in meters. In the case of nulled position components, the corresponding error covariance terms are omitted. """
    ERROR_MODEL_NONE = 0
    """ No additional error model provided (num_error_model_params = 0). """

    def __init__(self):
        self.icd_measurement_position = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.reference_frame = 0
        """
        Defines measurement reference.
        LCM Type: int8_t
        """

        self.term1 = 0.0
        """
        Description: First position term as defined in enum
        Units: various
        LCM Type: double
        """

        self.term2 = 0.0
        """
        Description: Second position term as defined in enum
        Units: various
        LCM Type: double
        """

        self.term3 = 0.0
        """
        Description: Third position term as defined in enum
        Units: various
        LCM Type: double
        """

        self.num_meas = 0
        """
        Description: Dimension of measurement provided
        Units: none
        LCM Type: int16_t
        """

        self.covariance = []
        """
        Description: Error covariance or variance depending on observation dimension
        Units: various Dimensions of covariance must be num_measÂ²
        LCM Type: double[num_meas][num_meas]
        """

        self.error_model = 0
        """
        Defines an optional error model for other than zero-mean, additive, white Gaussian noise (AWGN).
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model
        Units: various
        LCM Type: double[num_error_model_params]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity. Includes the integrity method used and an integrity value (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity > 1 is to report multiple integrity values based on multiple integrity methods
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(measurement_position._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_position))
        assert (
            self.header._get_packed_fingerprint()
            == aspn23_lcm.type_header._get_packed_fingerprint()
        )
        self.header._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        buf.write(
            struct.pack(
                ">bdddh",
                self.reference_frame,
                self.term1,
                self.term2,
                self.term3,
                self.num_meas,
            )
        )
        for i0 in range(self.num_meas):
            buf.write(
                struct.pack(
                    ">%dd" % self.num_meas, *self.covariance[i0][: self.num_meas]
                )
            )
        buf.write(struct.pack(">bi", self.error_model, self.num_error_model_params))
        buf.write(
            struct.pack(
                ">%dd" % self.num_error_model_params,
                *self.error_model_params[: self.num_error_model_params]
            )
        )
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert (
                self.integrity[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_integrity._get_packed_fingerprint()
            )
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_position._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_position._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_position()
        self.icd_measurement_position = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.reference_frame, self.term1, self.term2, self.term3, self.num_meas = (
            struct.unpack(">bdddh", buf.read(27))
        )
        self.covariance = []
        for i0 in range(self.num_meas):
            self.covariance.append(
                struct.unpack(">%dd" % self.num_meas, buf.read(self.num_meas * 8))
            )
        self.error_model, self.num_error_model_params = struct.unpack(
            ">bi", buf.read(5)
        )
        self.error_model_params = struct.unpack(
            ">%dd" % self.num_error_model_params,
            buf.read(self.num_error_model_params * 8),
        )
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_position in parents:
            return 0
        newparents = parents + [measurement_position]
        tmphash = (
            0xF8C23B6AECB77B7A
            + aspn23_lcm.type_header._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_integrity._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_position._packed_fingerprint is None:
            measurement_position._packed_fingerprint = struct.pack(
                ">Q", measurement_position._get_hash_recursive([])
            )
        return measurement_position._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", measurement_position._get_packed_fingerprint())[0]
