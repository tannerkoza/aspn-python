"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

"""
This code is generated via https://git.aspn.us/pntos/firehose/-/blob/main/firehose/backends/aspn/aspn_yaml_to_lcm.py
DO NOT hand edit code.  Make any changes required using the firehose repo instead
"""

from io import BytesIO
import struct

import aspn23_lcm

class type_metadataheader(object):
    """ Sensor metadata header. """

    __slots__ = ["icd_type_metadataheader", "header", "sensor_description", "delta_t_nom", "timestamp_clock_id", "digits_of_precision"]

    __typenames__ = ["int8_t", "aspn23_lcm.type_header", "string", "double", "int16_t", "int16_t"]

    __dimensions__ = [None, None, None, None, None, None]

    def __init__(self):
        self.icd_type_metadataheader = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header.
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.sensor_description = ""
        """
        Description: Describes the device used to generate the measurement (user defined).
        Units: none
        LCM Type: string
        """

        self.delta_t_nom = 0.0
        """
        Description: Optional nominal time interval between each measurement. Actual time interval may
        vary. Do not report a delta_t_nom if the nominal time interval is not known ahead of time.
        Units: seconds
        LCM Type: double
        """

        self.timestamp_clock_id = 0
        """
        Description: Identifier for the timestamp's clock/timing source. See clock_identifiers.md for a
        full description, but the summary is as follows:
        0 = ASPN System Time
        1 = International Atomic Time (TAI)
        2 = Universal Coordinated Time (UTC)
        3 = GPS System Time
        4 = Galileo System Time
        5 = GLONASS System Time
        6 = BeiDou System Time
        7-50: Reserved for future additional time scale representations.
        
        Each message source must provide metadata information (the method used to provide the metadata
        information depends on the system, e.g., over the wire, written to file, etc.), and the information
        contained in this type (type_metadataheader) will be included in that information. In this manner,
        each message source's clock ID will be defined. If the clock source is updated, new metadata must be
        provided with an updated clock ID.
        If used, ASPN system time shall be represented as a monotonically increasing quantity defined by
        the system. System time zero epoch must be defined. For example, system time may be the time
        difference with respect to a system power on event. Other user-defined clocks/timing sources must be
        similarly defined by the system designer.
        Units: none
        LCM Type: int16_t
        """

        self.digits_of_precision = 0
        """
        Description: Defines how many decimal digits of precision are represented in the timestamp after
        the decimal point. The precision of the timestamps is 10E-N, where N is digits_of_precision. A value
        of 3 would mean that the timestamp has precision at the 10E-3 (millisecond) level, a value of 6
        would mean the timestamp has precision at the 10E-6 (microsecond) level, etc.
        If an implementation is using 64bit integers for their internal time representations, digits of
        precision may be ignored with no additional complexity. If an implementation is converting to a
        double, because of their choice of internal representation (which likely most estimators would use),
        then knowing digits of precision would be important to avoid losing resolution.
        Units: none
        LCM Type: int16_t
        """


    def encode(self):
        buf = BytesIO()
        buf.write(type_metadataheader._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_type_metadataheader))
        assert self.header._get_packed_fingerprint() == aspn23_lcm.type_header._get_packed_fingerprint()
        self.header._encode_one(buf)
        __sensor_description_encoded = self.sensor_description.encode('utf-8')
        buf.write(struct.pack('>I', len(__sensor_description_encoded)+1))
        buf.write(__sensor_description_encoded)
        buf.write(b"\0")
        buf.write(struct.pack(">dhh", self.delta_t_nom, self.timestamp_clock_id, self.digits_of_precision))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_metadataheader._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_metadataheader._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_metadataheader()
        self.icd_type_metadataheader = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        __sensor_description_len = struct.unpack('>I', buf.read(4))[0]
        self.sensor_description = buf.read(__sensor_description_len)[:-1].decode('utf-8', 'replace')
        self.delta_t_nom, self.timestamp_clock_id, self.digits_of_precision = struct.unpack(">dhh", buf.read(12))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_metadataheader in parents: return 0
        newparents = parents + [type_metadataheader]
        tmphash = (0xe9550c5c6e6fe245+ aspn23_lcm.type_header._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_metadataheader._packed_fingerprint is None:
            type_metadataheader._packed_fingerprint = struct.pack(">Q", type_metadataheader._get_hash_recursive([]))
        return type_metadataheader._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", type_metadataheader._get_packed_fingerprint())[0]

