"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class measurement_time(object):
    """Expresses time measurements from one or more clocks/timing sources."""

    __slots__ = [
        "icd_measurement_time",
        "header",
        "time_of_validity",
        "time_of_validity_attosec",
        "num_obs",
        "clock_id",
        "elapsed_nsec",
        "elapsed_attosec",
        "digits_of_precision",
        "covariance",
        "error_model",
        "num_error_model_params",
        "error_model_params",
        "num_integrity",
        "integrity",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_header",
        "aspn23_lcm.type_timestamp",
        "int32_t",
        "int16_t",
        "int16_t",
        "int64_t",
        "int32_t",
        "int16_t",
        "double",
        "int8_t",
        "int32_t",
        "double",
        "int16_t",
        "aspn23_lcm.type_integrity",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        None,
        ["num_obs"],
        ["num_obs"],
        ["num_obs"],
        None,
        ["num_obs", "num_obs"],
        None,
        None,
        ["num_error_model_params"],
        None,
        ["num_integrity"],
    ]

    ERROR_MODEL_NONE = 0
    """ No additional error model provided (num_error_model_params = 0). """

    def __init__(self):
        self.icd_measurement_time = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.time_of_validity_attosec = 0
        """
        Description: Whole number of attoseconds used to provide additional timestamp fidelity describing the time at which the measurement is considered to be valid. This is only needed if the time of validity is known to more precision than 1ns; otherwise, set time_of_validity_attosec = 0. Be sure to report the timestamp's digits of precision in the `type_metadataheader` as part of the metadata. The full timestamp in nanoseconds is calculated as time_of_validity + ( time_of_validity_attosec * 1E-9 ) and if needed, a timestamp in seconds is calculated as time_of_validity * 1E-9 + time_of_validity_attosec * 1E-18 (Recall time_of_validity is in nanoseconds and time_of_validity_attosec is in attoseconds.) Furthermore, both time_of_validity and time_of_validity_attosec are signed integers and may be positive or negative. It is recommended to make time_of_validity and time_of_validity_attosec the same sign. Care should be taken when constructing the timestamp components to be sure the
        summation produces the desired result
        Units: attoseconds
        LCM Type: int32_t
        """

        self.num_obs = 0
        """
        Description: Number of absolute clock/timing source measurements reported in this measurement. May be 0 through 255. The clock_id, elapsed_nsec, and elapsed_attosec values are provided for each measurement, indexed by the observation number
        Units: none
        LCM Type: int16_t
        """

        self.clock_id = []
        """
        Description: Identifier for clock/timing source for each measurement. See clock_identifiers.md for a full description, but the summary is as follows: 0 = ASPN System Time 1 = International Atomic Time (TAI) 2 = Universal Coordinated Time (UTC) 3 = GPS System Time 4 = Galileo System Time 5 = GLONASS System Time 6 = BeiDou System Time 7-50: Reserved for future additional time scale representations
        Units: none
        LCM Type: int16_t[num_obs]
        """

        self.elapsed_nsec = []
        """
        Description: Whole number nanoseconds elapsed since each clock's zero epoch. If negative, whole number nanoseconds until each clock's zero epoch. Additionally, the timestamp's digits of precision are included as `digits_of_precision`
        Units: nanoseconds
        LCM Type: int64_t[num_obs]
        """

        self.elapsed_attosec = []
        """
        Description: Whole number of attoseconds used to provide additional observation fidelity. This is only needed if the observation is known to more precision than 1ns; otherwise, set time_of_validity_attosec = 0. Be sure to report the timestamp's digits of precision. The full observation in nanoseconds is calculated as elapsed_nsec + ( elapsed_attosec * 1E-9 ) and the observation in seconds is calculated as elapsed_nsec * 1E-9 + elapsed_attosec * 1E-18 Furthermore, both elapsed_nsec and elapsed_attosec are signed integers and may be positive or negative. It is recommended to make elapsed_nsec and elapsed_attosec the same sign. Care should be taken when constructing the observation components to be sure the summation produces the desired result
        Units: attoseconds
        LCM Type: int32_t[num_obs]
        """

        self.digits_of_precision = 0
        """
        Description: Defines how many decimal digits of precision are represented in the observation after the decimal point. The precision of the observation is 10E-N, where N is digits_of_precision. A value of 3 would mean that the observation has precision at the 10E-3 (millisecond) level, a value of 6 would mean the observation has precision at the 10E-6 (microsecond) level, etc
        Units: none
        LCM Type: int16_t
        """

        self.covariance = []
        """
        Description: Measurement error variance or covariance depending on measurement dimension in the absolute clock/timing signal measurements. Note: These measurements are assuming that there is no error in the ASPN system clock. Errors in the ASPN system clock time tag for the time measurements should be included in the overall errors for the respective time measurements as expressed in the covariance matrix
        Units: sec^2 Dimensions of covariance must be num_obsÂ²
        LCM Type: double[num_obs][num_obs]
        """

        self.error_model = 0
        """
        Defines an optional error model for other than zero-mean, additive, white Gaussian noise (AWGN).
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model
        Units: various
        LCM Type: double[num_error_model_params]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity. Includes the integrity method used and an integrity value (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity > 1 is to report multiple integrity values based on multiple integrity methods
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(measurement_time._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_time))
        assert (
            self.header._get_packed_fingerprint()
            == aspn23_lcm.type_header._get_packed_fingerprint()
        )
        self.header._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        buf.write(struct.pack(">ih", self.time_of_validity_attosec, self.num_obs))
        buf.write(struct.pack(">%dh" % self.num_obs, *self.clock_id[: self.num_obs]))
        buf.write(
            struct.pack(">%dq" % self.num_obs, *self.elapsed_nsec[: self.num_obs])
        )
        buf.write(
            struct.pack(">%di" % self.num_obs, *self.elapsed_attosec[: self.num_obs])
        )
        buf.write(struct.pack(">h", self.digits_of_precision))
        for i0 in range(self.num_obs):
            buf.write(
                struct.pack(">%dd" % self.num_obs, *self.covariance[i0][: self.num_obs])
            )
        buf.write(struct.pack(">bi", self.error_model, self.num_error_model_params))
        buf.write(
            struct.pack(
                ">%dd" % self.num_error_model_params,
                *self.error_model_params[: self.num_error_model_params]
            )
        )
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert (
                self.integrity[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_integrity._get_packed_fingerprint()
            )
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_time._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_time._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_time()
        self.icd_measurement_time = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.time_of_validity_attosec, self.num_obs = struct.unpack(">ih", buf.read(6))
        self.clock_id = struct.unpack(">%dh" % self.num_obs, buf.read(self.num_obs * 2))
        self.elapsed_nsec = struct.unpack(
            ">%dq" % self.num_obs, buf.read(self.num_obs * 8)
        )
        self.elapsed_attosec = struct.unpack(
            ">%di" % self.num_obs, buf.read(self.num_obs * 4)
        )
        self.digits_of_precision = struct.unpack(">h", buf.read(2))[0]
        self.covariance = []
        for i0 in range(self.num_obs):
            self.covariance.append(
                struct.unpack(">%dd" % self.num_obs, buf.read(self.num_obs * 8))
            )
        self.error_model, self.num_error_model_params = struct.unpack(
            ">bi", buf.read(5)
        )
        self.error_model_params = struct.unpack(
            ">%dd" % self.num_error_model_params,
            buf.read(self.num_error_model_params * 8),
        )
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_time in parents:
            return 0
        newparents = parents + [measurement_time]
        tmphash = (
            0xACC221E035BA92C7
            + aspn23_lcm.type_header._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_integrity._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_time._packed_fingerprint is None:
            measurement_time._packed_fingerprint = struct.pack(
                ">Q", measurement_time._get_hash_recursive([])
            )
        return measurement_time._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", measurement_time._get_packed_fingerprint())[0]
