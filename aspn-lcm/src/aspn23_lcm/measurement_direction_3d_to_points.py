"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class measurement_direction_3d_to_points(object):
    """3D direction to points."""

    __slots__ = [
        "icd_measurement_direction_3d_to_points",
        "header",
        "time_of_validity",
        "num_obs",
        "obs",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_header",
        "aspn23_lcm.type_timestamp",
        "int32_t",
        "aspn23_lcm.type_direction_3d_to_point",
    ]

    __dimensions__ = [None, None, None, None, ["num_obs"]]

    def __init__(self):
        self.icd_measurement_direction_3d_to_points = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.num_obs = 0
        """
        Description: Total number of observations
        Units: none
        LCM Type: int32_t
        """

        self.obs = []
        """
        Description: Array of observations
        Units: none
        LCM Type: aspn23_lcm.type_direction_3d_to_point[num_obs]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(measurement_direction_3d_to_points._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_direction_3d_to_points))
        assert (
            self.header._get_packed_fingerprint()
            == aspn23_lcm.type_header._get_packed_fingerprint()
        )
        self.header._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        buf.write(struct.pack(">i", self.num_obs))
        for i0 in range(self.num_obs):
            assert (
                self.obs[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_direction_3d_to_point._get_packed_fingerprint()
            )
            self.obs[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_direction_3d_to_points._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_direction_3d_to_points._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_direction_3d_to_points()
        self.icd_measurement_direction_3d_to_points = struct.unpack(">b", buf.read(1))[
            0
        ]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.num_obs = struct.unpack(">i", buf.read(4))[0]
        self.obs = []
        for i0 in range(self.num_obs):
            self.obs.append(aspn23_lcm.type_direction_3d_to_point._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_direction_3d_to_points in parents:
            return 0
        newparents = parents + [measurement_direction_3d_to_points]
        tmphash = (
            0x3457C11BDFA63587
            + aspn23_lcm.type_header._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_direction_3d_to_point._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_direction_3d_to_points._packed_fingerprint is None:
            measurement_direction_3d_to_points._packed_fingerprint = struct.pack(
                ">Q", measurement_direction_3d_to_points._get_hash_recursive([])
            )
        return measurement_direction_3d_to_points._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(
            ">Q", measurement_direction_3d_to_points._get_packed_fingerprint()
        )[0]
