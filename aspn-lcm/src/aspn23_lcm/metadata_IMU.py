"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class metadata_IMU(object):
    """Metadata for inertial measurement unit."""

    __slots__ = [
        "icd_metadata_IMU",
        "info",
        "time_of_validity",
        "mounting",
        "error_model",
        "num_error_model_params",
        "error_model_params",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_metadataheader",
        "aspn23_lcm.type_timestamp",
        "aspn23_lcm.type_mounting",
        "int8_t",
        "int32_t",
        "double",
    ]

    __dimensions__ = [None, None, None, None, None, None, ["num_error_model_params"]]

    ERROR_MODEL_BASIC = 0
    """
    All axes are identical and uncorrelated with each other axis (num_error_model_params = 14). 1) accel_bias_sigma, units: m/s/s, description: Standard deviation of constant bias for accelerometer measurements. 2) accel_bias_mean, units: m/s/s, description: Mean of constant bias for accelerometer measurements. 3) accel_time_correlated_bias_sigma, units: m/s/s, description: Standard deviation of zero-mean time-correlated bias for accelerometer measurement. 4) accel_time_correlated_bias_time_constant, units: s, description: Time constant of zero-mean time-correlated bias for accelerometer measurement. 5) accel_scale_factor_mean, units: ppm, description: Mean of accelerometer scale factor modeled as a constant with Gaussian uncertainty. 6) accel_scale_factor_sigma, units: ppm, description: Standard deviation of accelerometer scale factor modeled as a constant with Gaussian uncertainty. 7) velocity_random_walk, units: m/s/sqrt(s), description: Velocity random walk due to acceleration. 8)
    gyro_bias_sigma, units: rad/s, description: Standard deviation of constant bias for gyro measurements. 9) gyro_bias_mean, units: rad/s, description: Mean of constant bias for gyro measurements. 10) gyro_time_correlated_bias_sigma, units: rad/s, description: Standard deviation of zero-mean time-correlated bias for gyro measurements. 11) gyro_time_correlated_bias_time_constant, units: s, description: Time constant of zero-mean time-correlated bias for gyro measurements. 12) gyro_scale_factor_mean, units: ppm, description: Mean of gyro scale factor modeled as a constant with Gaussian uncertainty. 13) gyro_scale_factor_sigma, units: ppm, description: Standard deviation of gyro scale factor modeled as a constant with Gaussian uncertainty. 14) angular_random_walk, units: rad/sqrt(s), description: Angular random walk due to gyros.
    """

    def __init__(self):
        self.icd_metadata_IMU = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.info = aspn23_lcm.type_metadataheader()
        """
        Description: Standard ASPN metadata header
        Units: none
        LCM Type: aspn23_lcm.type_metadataheader
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.mounting = aspn23_lcm.type_mounting()
        """
        Description: Standard ASPN mounting information
        Units: none
        LCM Type: aspn23_lcm.type_mounting
        """

        self.error_model = 0
        """
        Allows the user to select an appropriate error model. Parameters are defined here. The number of parameters and the values for those parameters are included in subsequent fields.
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model
        Units: various
        LCM Type: double[num_error_model_params]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(metadata_IMU._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_metadata_IMU))
        assert (
            self.info._get_packed_fingerprint()
            == aspn23_lcm.type_metadataheader._get_packed_fingerprint()
        )
        self.info._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        assert (
            self.mounting._get_packed_fingerprint()
            == aspn23_lcm.type_mounting._get_packed_fingerprint()
        )
        self.mounting._encode_one(buf)
        buf.write(struct.pack(">bi", self.error_model, self.num_error_model_params))
        buf.write(
            struct.pack(
                ">%dd" % self.num_error_model_params,
                *self.error_model_params[: self.num_error_model_params]
            )
        )

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != metadata_IMU._get_packed_fingerprint():
            raise ValueError("Decode error")
        return metadata_IMU._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = metadata_IMU()
        self.icd_metadata_IMU = struct.unpack(">b", buf.read(1))[0]
        self.info = aspn23_lcm.type_metadataheader._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.mounting = aspn23_lcm.type_mounting._decode_one(buf)
        self.error_model, self.num_error_model_params = struct.unpack(
            ">bi", buf.read(5)
        )
        self.error_model_params = struct.unpack(
            ">%dd" % self.num_error_model_params,
            buf.read(self.num_error_model_params * 8),
        )
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if metadata_IMU in parents:
            return 0
        newparents = parents + [metadata_IMU]
        tmphash = (
            0x122614F90CE6E8F8
            + aspn23_lcm.type_metadataheader._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_mounting._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if metadata_IMU._packed_fingerprint is None:
            metadata_IMU._packed_fingerprint = struct.pack(
                ">Q", metadata_IMU._get_hash_recursive([])
            )
        return metadata_IMU._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", metadata_IMU._get_packed_fingerprint())[0]
