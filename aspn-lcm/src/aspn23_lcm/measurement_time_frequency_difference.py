"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

"""
This code is generated via https://git.aspn.us/pntos/firehose/-/blob/main/firehose/backends/aspn/aspn_yaml_to_lcm.py
DO NOT hand edit code.  Make any changes required using the firehose repo instead
"""

from io import BytesIO
import struct

import aspn23_lcm

class measurement_time_frequency_difference(object):
    """
    Time and frequency difference between two clocks or timing sources. This measurement
    requires both time and frequency to be provided.
    """

    __slots__ = ["icd_measurement_time_frequency_difference", "header", "time_of_validity", "time_of_validity_attosec", "clock_id1", "clock_id2", "time_diff_nsec", "time_diff_attosec", "digits_of_precision", "freq_diff", "covariance", "error_model", "num_error_model_params", "error_model_params", "num_integrity", "integrity"]

    __typenames__ = ["int8_t", "aspn23_lcm.type_header", "aspn23_lcm.type_timestamp", "int32_t", "int16_t", "int16_t", "int64_t", "int32_t", "int16_t", "double", "double", "int8_t", "int32_t", "double", "int16_t", "aspn23_lcm.type_integrity"]

    __dimensions__ = [None, None, None, None, None, None, None, None, None, None, [2, 2], None, None, ["num_error_model_params"], None, ["num_integrity"]]

    ERROR_MODEL_NONE = 0
    """ No additional error model provided (num_error_model_params = 0). """

    def __init__(self):
        self.icd_measurement_time_frequency_difference = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header.
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid.
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.time_of_validity_attosec = 0
        """
        Description: Whole number of attoseconds used to provide additional timestamp fidelity
        describing the time at
        which the measurement is considered to be valid. This is only needed if the time of validity is
        known to more precision than 1ns; otherwise, set time_of_validity_attosec = 0. Be sure to
        report the timestamp's digits of precision in the `type_metadataheader` as part of the metadata.
        
        The full timestamp in nanoseconds is calculated as
        
        time_of_validity + ( time_of_validity_attosec * 1E-9 )
        
        and if needed, a timestamp in seconds is calculated as
        
        time_of_validity * 1E-9 + time_of_validity_attosec * 1E-18
        
        (Recall time_of_validity is in nanoseconds and time_of_validity_attosec is in attoseconds.)
        Furthermore, both time_of_validity and time_of_validity_attosec are signed integers and may be
        positive or negative. It is recommended to make time_of_validity and time_of_validity_attosec
        the same sign. Care should be taken when constructing the timestamp components to be sure the
        summation produces the desired result.
        Units: attoseconds
        LCM Type: int32_t
        """

        self.clock_id1 = 0
        """
        Description: Identifier for clock/timing source 2. See clock_identifiers.md for a full
        description, but the
        summary is as follows:
        0 = ASPN System Time
        1 = International Atomic Time (TAI)
        2 = Universal Coordinated Time (UTC)
        3 = GPS System Time
        4 = Galileo System Time
        5 = GLONASS System Time
        6 = BeiDou System Time
        7-50: Reserved for future additional time scale representations.
        Units: none
        LCM Type: int16_t
        """

        self.clock_id2 = 0
        """
        Description: Identifier for clock/timing source 2. See clock_identifiers.md for a full
        description, but the summary is as follows:
        0 = ASPN System Time
        1 = International Atomic Time (TAI)
        2 = Universal Coordinated Time (UTC)
        3 = GPS System Time
        4 = Galileo System Time
        5 = GLONASS System Time
        6 = BeiDou System Time
        7-50: Reserved for future additional time scale representations.
        Units: none
        LCM Type: int16_t
        """

        self.time_diff_nsec = 0
        """
        Description: Whole number nanoseconds in time difference (time from clock_id1) - (time from
        clock_id2). Must be less than 1e9. This value shall be positive when (time from clock_id1) - (time
        from clock_id2) is greater than or equal to zero. This value shall be negative when (time from
        clock_id1) - (time from clock_id2) is less than zero.Additionally, the timestamp's digits of
        precision are included as `digits_of_precision`.
        Units: nanoseconds
        LCM Type: int64_t
        """

        self.time_diff_attosec = 0
        """
        Description: Whole number attoseconds in time difference (time from clock_id1) - (time from
        clock_id2). Must be less than 1e9. This value shall be positive when (time from clock_id1) - (time
        from clock_id2) is greater than or equal to zero. This value shall be negative when (time from
        clock_id1) - (time from clock_id2) is less than zero.
        This is only needed if the time of validity is known to more precision than 1ns; otherwise, set
        time_of_validity_attosec = 0. Be sure to report the timestamp's digits of precision.
        The time difference in seconds is calculated as
        
        time difference = time_diff_nsec * 1e-9 + time_diff_attosec * 1e-18
        
        It shall be assumed that time_diff_nsec and time_diff_attosec have the same sign. Therefore, the
        time difference is positive when (time from clock_id1) - (time from clock_id2) is positive and the
        time difference is negative when (time from clock_id1) - (time from clock_id2) is negative.
        A cautionary note: Both timediff_nsec and time_diff_attosec are signed integers and may be
        positive or negative. It is mandated to make timediff_nsec and time_diff_attosec the same sign;
        however, care should be taken when constructing the observation components to be sure the summation
        produces the desired result.
        Units: attoseconds
        LCM Type: int32_t
        """

        self.digits_of_precision = 0
        """
        Description: Defines how many decimal digits of precision are represented in the observation
        after the decimal point. The precision of the observation is 10E-N, where N is digits_of_precision.
        A value of 3 would mean that the observation has precision at the 10E-3 (millisecond) level, a value
        of 6 would mean the observation has precision at the 10E-6 (microsecond) level, etc.
        Units: none
        LCM Type: int16_t
        """

        self.freq_diff = 0.0
        """
        Description: Frequency difference formed as (frequency from clock_id1) - (frequency from
        clock_id2).
        Units: Hertz
        LCM Type: double
        """

        self.covariance = [ [ 0.0 for dim1 in range(2) ] for dim0 in range(2) ]
        """
        Description: Covariance information for the time/frequency measurement. Using zero-indexing, the
        [0,0] element has units of sec^2, the [1,1] element has units of Hertz^2, and the off-diagonal terms
        have units of sec*Hertz.
        Units: various
        LCM Type: double[2][2]
        """

        self.error_model = 0
        """
        Defines an optional error model for other than zero-mean, additive, white Gaussian noise (AWGN).
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen.
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model.
        Units: various
        LCM Type: double[num_error_model_params]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values.
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity. Includes the integrity method used and an integrity value
        (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity >
        1 is to report multiple integrity values based on multiple integrity methods.
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """


    def encode(self):
        buf = BytesIO()
        buf.write(measurement_time_frequency_difference._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_time_frequency_difference))
        assert self.header._get_packed_fingerprint() == aspn23_lcm.type_header._get_packed_fingerprint()
        self.header._encode_one(buf)
        assert self.time_of_validity._get_packed_fingerprint() == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        self.time_of_validity._encode_one(buf)
        buf.write(struct.pack(">ihhqihd", self.time_of_validity_attosec, self.clock_id1, self.clock_id2, self.time_diff_nsec, self.time_diff_attosec, self.digits_of_precision, self.freq_diff))
        for i0 in range(2):
            buf.write(struct.pack('>2d', *self.covariance[i0][:2]))
        buf.write(struct.pack(">bi", self.error_model, self.num_error_model_params))
        buf.write(struct.pack('>%dd' % self.num_error_model_params, *self.error_model_params[:self.num_error_model_params]))
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert self.integrity[i0]._get_packed_fingerprint() == aspn23_lcm.type_integrity._get_packed_fingerprint()
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_time_frequency_difference._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_time_frequency_difference._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_time_frequency_difference()
        self.icd_measurement_time_frequency_difference = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.time_of_validity_attosec, self.clock_id1, self.clock_id2, self.time_diff_nsec, self.time_diff_attosec, self.digits_of_precision, self.freq_diff = struct.unpack(">ihhqihd", buf.read(30))
        self.covariance = []
        for i0 in range(2):
            self.covariance.append(struct.unpack('>2d', buf.read(16)))
        self.error_model, self.num_error_model_params = struct.unpack(">bi", buf.read(5))
        self.error_model_params = struct.unpack('>%dd' % self.num_error_model_params, buf.read(self.num_error_model_params * 8))
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_time_frequency_difference in parents: return 0
        newparents = parents + [measurement_time_frequency_difference]
        tmphash = (0xbbe2231dfc38c878+ aspn23_lcm.type_header._get_hash_recursive(newparents)+ aspn23_lcm.type_timestamp._get_hash_recursive(newparents)+ aspn23_lcm.type_integrity._get_hash_recursive(newparents)) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_time_frequency_difference._packed_fingerprint is None:
            measurement_time_frequency_difference._packed_fingerprint = struct.pack(">Q", measurement_time_frequency_difference._get_hash_recursive([]))
        return measurement_time_frequency_difference._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", measurement_time_frequency_difference._get_packed_fingerprint())[0]

