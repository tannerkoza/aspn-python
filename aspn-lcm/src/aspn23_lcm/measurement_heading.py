"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class measurement_heading(object):
    """
    Local level, geographic attitude expressed in the locally level NED frame as a
    rotation about the D-axis. Positive rotation follows the right-hand rule.
    Attitude about the other axes in the NED-frame are unspecified and not sensed.
    Use attitude_2d or attitude_3d to report a sensed dimension that is zero. See
    also NED coordinate frame definition for N, E, and D definitions.
    """

    __slots__ = [
        "icd_measurement_heading",
        "header",
        "time_of_validity",
        "reference",
        "obs",
        "variance",
        "error_model",
        "num_error_model_params",
        "error_model_params",
        "num_integrity",
        "integrity",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_header",
        "aspn23_lcm.type_timestamp",
        "int8_t",
        "double",
        "double",
        "int8_t",
        "int32_t",
        "double",
        "int16_t",
        "aspn23_lcm.type_integrity",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        None,
        ["num_error_model_params"],
        None,
        ["num_integrity"],
    ]

    REFERENCE_TRUE_HEADING = 0
    """ True heading. Direction to the geographic north expressed in the locally level NED frame as a rotation about the D-axis. This is akin to attitude_1d, which would be consistent with attitude_2d and attitude_3d. In that case, a ref frame enum could be used to define multiple one-dimensional attitudes, of which, heading could be one. The simpler approach of just having heading was chosen over the more general approach until there is a requirement for multiple, one-dimensional attitudes. """
    REFERENCE_MAGNETIC_HEADING = 1
    """ Magnetic heading. Direction to magnetic north expressed in the locally level NED frame as a rotation about the D-axis. In general, geographic position and time is required to convert from magnetic heading to true heading. """
    ERROR_MODEL_NONE = 0
    """ No additional error model provided (num_error_model_params = 0). """

    def __init__(self):
        self.icd_measurement_heading = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.reference = 0
        """
        Defines heading reference.
        LCM Type: int8_t
        """

        self.obs = 0.0
        """
        Description: Heading
        Units: rad
        LCM Type: double
        """

        self.variance = 0.0
        """
        Description: Variance of the measurement
        Units: rad^2
        LCM Type: double
        """

        self.error_model = 0
        """
        Defines an optional error model for other than zero-mean, additive, white Gaussian noise (AWGN).
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model
        Units: various
        LCM Type: double[num_error_model_params]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity. Includes the integrity method used and an integrity value (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity > 1 is to report multiple integrity values based on multiple integrity methods
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(measurement_heading._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_heading))
        assert (
            self.header._get_packed_fingerprint()
            == aspn23_lcm.type_header._get_packed_fingerprint()
        )
        self.header._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        buf.write(
            struct.pack(
                ">bddbi",
                self.reference,
                self.obs,
                self.variance,
                self.error_model,
                self.num_error_model_params,
            )
        )
        buf.write(
            struct.pack(
                ">%dd" % self.num_error_model_params,
                *self.error_model_params[: self.num_error_model_params]
            )
        )
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert (
                self.integrity[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_integrity._get_packed_fingerprint()
            )
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_heading._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_heading._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_heading()
        self.icd_measurement_heading = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        (
            self.reference,
            self.obs,
            self.variance,
            self.error_model,
            self.num_error_model_params,
        ) = struct.unpack(">bddbi", buf.read(22))
        self.error_model_params = struct.unpack(
            ">%dd" % self.num_error_model_params,
            buf.read(self.num_error_model_params * 8),
        )
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_heading in parents:
            return 0
        newparents = parents + [measurement_heading]
        tmphash = (
            0xF518028C3B85F11
            + aspn23_lcm.type_header._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_integrity._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_heading._packed_fingerprint is None:
            measurement_heading._packed_fingerprint = struct.pack(
                ">Q", measurement_heading._get_hash_recursive([])
            )
        return measurement_heading._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", measurement_heading._get_packed_fingerprint())[0]
