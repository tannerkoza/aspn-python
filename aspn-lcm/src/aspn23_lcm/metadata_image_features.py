"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class metadata_image_features(object):
    """Features from an optical camera."""

    __slots__ = [
        "icd_metadata_image_features",
        "info",
        "time_of_validity",
        "keypoint_detector",
        "orientation_calculated",
        "descriptor_extractor",
        "is_bigendian",
        "descriptor_type",
        "descriptor_number_of_elements",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_metadataheader",
        "aspn23_lcm.type_timestamp",
        "int8_t",
        "boolean",
        "int8_t",
        "boolean",
        "int8_t",
        "int32_t",
    ]

    __dimensions__ = [None, None, None, None, None, None, None, None, None]

    KEYPOINT_DETECTOR_DET_AGAST = 0
    """ Keypoint detected using AGAST based detector. """
    KEYPOINT_DETECTOR_DET_AKAZE = 1
    """ Keypoint detected using AKAZE based detector. """
    KEYPOINT_DETECTOR_DET_BRISK = 2
    """ Keypoint detected using BRISK based detector. """
    KEYPOINT_DETECTOR_DET_FAST = 3
    """ Keypoint detected using FAST based detector. """
    KEYPOINT_DETECTOR_DET_GFTT = 4
    """ Keypoint detected using GFTT based detector. """
    KEYPOINT_DETECTOR_DET_KAZE = 5
    """ Keypoint detected using KAZE based detector. """
    KEYPOINT_DETECTOR_DET_MSER = 6
    """ Keypoint detected using MSER based detector. """
    KEYPOINT_DETECTOR_DET_ORB = 7
    """ Keypoint detected using ORB based detector. """
    KEYPOINT_DETECTOR_DET_SIFT = 8
    """ Keypoint detected using SIFT based detector. """
    KEYPOINT_DETECTOR_DET_SURF = 9
    """ Keypoint detected using SURF based detector. """
    KEYPOINT_DETECTOR_DET_HARRIS = 10
    """ Keypoint detected using Harris based detector. """
    KEYPOINT_DETECTOR_DET_SHI = 11
    """ Keypoint detected using Shi-Tomasi based detector. """
    KEYPOINT_DETECTOR_DET_OTHER = 12
    """ Keypoint detected using a detector not represented in this enum. """
    DESCRIPTOR_EXTRACTOR_DESC_AKAZE = 0
    """ Descriptor computed using the AKAZE extractor. """
    DESCRIPTOR_EXTRACTOR_DESC_BRISK = 1
    """ Descriptor computed using the BRISK extractor. """
    DESCRIPTOR_EXTRACTOR_DESC_KAZE = 2
    """ Descriptor computed using the KAZE extractor. """
    DESCRIPTOR_EXTRACTOR_DESC_ORB = 3
    """ Descriptor computed using the ORB extractor. """
    DESCRIPTOR_EXTRACTOR_DESC_SIFT = 4
    """ Descriptor computed using the SIFT extractor. """
    DESCRIPTOR_EXTRACTOR_DESC_SURF = 5
    """ Descriptor computed using the SURF extractor. """
    DESCRIPTOR_EXTRACTOR_DESC_OTHER = 6
    """ Descriptor computed using an extractor not represented in this enum. """
    DESCRIPTOR_TYPE_UINT8 = 0
    """ The descriptor data should be interpreted as an array of unsigned 8-bit ints. """
    DESCRIPTOR_TYPE_FLOAT32 = 1
    """ The descriptor data should be interpreted as an array of 32-bit floats. """

    def __init__(self):
        self.icd_metadata_image_features = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.info = aspn23_lcm.type_metadataheader()
        """
        Description: Standard ASPN metadata header
        Units: none
        LCM Type: aspn23_lcm.type_metadataheader
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.keypoint_detector = 0
        """
        Enumerated field which provides the type of keypoint detector used.
        LCM Type: int8_t
        """

        self.orientation_calculated = False
        """
        Description: Set to true if the keypoint detector or descriptor extractor calculates and assigns a primary orientation to the features represented in the measurements
        Units: none
        LCM Type: boolean
        """

        self.descriptor_extractor = 0
        """
        Enumerated field which provides the type of descriptor extractor used to generate the measurement descriptor vector.
        LCM Type: int8_t
        """

        self.is_bigendian = False
        """
        Description: True if the descriptor byte order is big endian, false if it is little endian. Only applicable for descriptor_types with multi-byte elements
        Units: none
        LCM Type: boolean
        """

        self.descriptor_type = 0
        """
        Enumerated field describing the underlying datatype of the provided descriptor vector.
        LCM Type: int8_t
        """

        self.descriptor_number_of_elements = 0
        """
        Description: The number of elements of type 'descriptor_type' in the descriptor data array. In type_image_feature, descriptor data is represented as an array of uint8 values whose length is given by 'descriptor_size'. Inconjunction with descriptor_type, these fields describe how that data should be interpreted. For example - descriptor_type UINT8: descriptor_number_of_elements == descriptor_size - descriptor_type FLOAT32: (descriptor_number_of_elements * 4) == descriptor_size Units: none
        LCM Type: int32_t
        """

    def encode(self):
        buf = BytesIO()
        buf.write(metadata_image_features._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_metadata_image_features))
        assert (
            self.info._get_packed_fingerprint()
            == aspn23_lcm.type_metadataheader._get_packed_fingerprint()
        )
        self.info._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        buf.write(
            struct.pack(
                ">bbbbbi",
                self.keypoint_detector,
                self.orientation_calculated,
                self.descriptor_extractor,
                self.is_bigendian,
                self.descriptor_type,
                self.descriptor_number_of_elements,
            )
        )

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != metadata_image_features._get_packed_fingerprint():
            raise ValueError("Decode error")
        return metadata_image_features._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = metadata_image_features()
        self.icd_metadata_image_features = struct.unpack(">b", buf.read(1))[0]
        self.info = aspn23_lcm.type_metadataheader._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.keypoint_detector = struct.unpack(">b", buf.read(1))[0]
        self.orientation_calculated = bool(struct.unpack("b", buf.read(1))[0])
        self.descriptor_extractor = struct.unpack(">b", buf.read(1))[0]
        self.is_bigendian = bool(struct.unpack("b", buf.read(1))[0])
        self.descriptor_type, self.descriptor_number_of_elements = struct.unpack(
            ">bi", buf.read(5)
        )
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if metadata_image_features in parents:
            return 0
        newparents = parents + [metadata_image_features]
        tmphash = (
            0xEC486CDD2ED94097
            + aspn23_lcm.type_metadataheader._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if metadata_image_features._packed_fingerprint is None:
            metadata_image_features._packed_fingerprint = struct.pack(
                ">Q", metadata_image_features._get_hash_recursive([])
            )
        return metadata_image_features._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", metadata_image_features._get_packed_fingerprint())[0]
