"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class metadata_magnetic_field(object):
    """
    Metadata for a magnetic field measurement. In addition to generic metadata
    information, calibration parameters may be provided to account for effects such
    as soft iron, scale factor, non-orthogonality, zero-bias, and hard iron. In
    general, for an num_meas-dimensional measurement, the magnetic field calibration
    metadata (K and b) shall be used as m_calibrated = K * m_measured - b where
    m_calibrated, m_measured, and b are num_meas x 1 vectors (scalar for num_meas =
    1) and K is an num_meas x num_meas matrix (scalar for num_meas = 1). See
    magnetic_calibration.md for additional details. More sophisticated approaches
    that include calibration parameters such as time-varying effects, first-order
    Gauss-Markov bias models, and calibration parameter uncertainties may be
    included using an appropriate error model in the measurement message.
    """

    __slots__ = [
        "icd_metadata_magnetic_field",
        "info",
        "time_of_validity",
        "mounting",
        "num_meas",
        "k",
        "b",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_metadataheader",
        "aspn23_lcm.type_timestamp",
        "aspn23_lcm.type_mounting",
        "int16_t",
        "double",
        "double",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        None,
        ["num_meas", "num_meas"],
        ["num_meas"],
    ]

    def __init__(self):
        self.icd_metadata_magnetic_field = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.info = aspn23_lcm.type_metadataheader()
        """
        Description: Standard ASPN metadata header
        Units: none
        LCM Type: aspn23_lcm.type_metadataheader
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.mounting = aspn23_lcm.type_mounting()
        """
        Description: Standard ASPN mounting information
        Units: none
        LCM Type: aspn23_lcm.type_mounting
        """

        self.num_meas = 0
        """
        Description: Dimension of measurement for which this metadata is applicable. May be 1, 2, or 3
        Units: none
        LCM Type: int16_t
        """

        self.k = []
        """
        Description: Optional calibration parameter to account for the combined effects of soft iron, scale factor, and non-orthogonality as a unitless num_meas x num_meas matrix. Optional, but if provided, b must also be provided
        Units: none
        LCM Type: double[num_meas][num_meas]
        """

        self.b = []
        """
        Description: Optional calibration parameter to account for the combined effects of zero-bias and hard iron as a num_meas x 1 vector in nanoTesla (nT). Optional, but if provided, K must also be provided
        Units: nT
        LCM Type: double[num_meas]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(metadata_magnetic_field._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_metadata_magnetic_field))
        assert (
            self.info._get_packed_fingerprint()
            == aspn23_lcm.type_metadataheader._get_packed_fingerprint()
        )
        self.info._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        assert (
            self.mounting._get_packed_fingerprint()
            == aspn23_lcm.type_mounting._get_packed_fingerprint()
        )
        self.mounting._encode_one(buf)
        buf.write(struct.pack(">h", self.num_meas))
        for i0 in range(self.num_meas):
            buf.write(struct.pack(">%dd" % self.num_meas, *self.k[i0][: self.num_meas]))
        buf.write(struct.pack(">%dd" % self.num_meas, *self.b[: self.num_meas]))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != metadata_magnetic_field._get_packed_fingerprint():
            raise ValueError("Decode error")
        return metadata_magnetic_field._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = metadata_magnetic_field()
        self.icd_metadata_magnetic_field = struct.unpack(">b", buf.read(1))[0]
        self.info = aspn23_lcm.type_metadataheader._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.mounting = aspn23_lcm.type_mounting._decode_one(buf)
        self.num_meas = struct.unpack(">h", buf.read(2))[0]
        self.k = []
        for i0 in range(self.num_meas):
            self.k.append(
                struct.unpack(">%dd" % self.num_meas, buf.read(self.num_meas * 8))
            )
        self.b = struct.unpack(">%dd" % self.num_meas, buf.read(self.num_meas * 8))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if metadata_magnetic_field in parents:
            return 0
        newparents = parents + [metadata_magnetic_field]
        tmphash = (
            0xEC9DBDEE1877DC68
            + aspn23_lcm.type_metadataheader._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_mounting._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if metadata_magnetic_field._packed_fingerprint is None:
            metadata_magnetic_field._packed_fingerprint = struct.pack(
                ">Q", metadata_magnetic_field._get_hash_recursive([])
            )
        return metadata_magnetic_field._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", metadata_magnetic_field._get_packed_fingerprint())[0]
