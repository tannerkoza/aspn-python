"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class measurement_satnav(object):
    """Raw measurements from a satnav receiver."""

    __slots__ = [
        "icd_measurement_satnav",
        "header",
        "time_of_validity",
        "receiver_clock_time",
        "num_signal_types",
        "num_signals_tracked",
        "obs",
        "num_integrity",
        "integrity",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_header",
        "aspn23_lcm.type_timestamp",
        "aspn23_lcm.type_satnav_time",
        "int32_t",
        "int32_t",
        "aspn23_lcm.type_satnav_obs",
        "int16_t",
        "aspn23_lcm.type_integrity",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        None,
        None,
        ["num_signals_tracked"],
        None,
        ["num_integrity"],
    ]

    def __init__(self):
        self.icd_measurement_satnav = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.receiver_clock_time = aspn23_lcm.type_satnav_time()
        """
        Description: Receiver clock time. In a multi-GNSS receiver (GPS/GLONASS/Galileo/QZSS/BeiDou) all pseudorange observations must refer to one receiver clock only. The receiver clock time of the measurement is the receiver clock time of the received signals. It is identical for the phase and range measurements and is identical for all satellites observed in a given epoch
        Units: none
        LCM Type: aspn23_lcm.type_satnav_time
        """

        self.num_signal_types = 0
        """
        Description: Number of different signal types tracked in the current epoch. Examples of signal types include GPS L1 C/A code, Galileo E1B
        Units: none
        LCM Type: int32_t
        """

        self.num_signals_tracked = 0
        """
        Description: Total number of signals tracked across all PRNs and signal types
        Units: none
        LCM Type: int32_t
        """

        self.obs = []
        """
        Description: Array of satnav obs data for all of the signals/PRNs being tracked in this epoch
        Units: none
        LCM Type: aspn23_lcm.type_satnav_obs[num_signals_tracked]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity at the sensor level. Integrity is also available for each observable, which is found in the observable type definition. Includes the integrity method used and an integrity value (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity > 1 is to report multiple integrity values based on multiple integrity methods
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(measurement_satnav._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_satnav))
        assert (
            self.header._get_packed_fingerprint()
            == aspn23_lcm.type_header._get_packed_fingerprint()
        )
        self.header._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        assert (
            self.receiver_clock_time._get_packed_fingerprint()
            == aspn23_lcm.type_satnav_time._get_packed_fingerprint()
        )
        self.receiver_clock_time._encode_one(buf)
        buf.write(struct.pack(">ii", self.num_signal_types, self.num_signals_tracked))
        for i0 in range(self.num_signals_tracked):
            assert (
                self.obs[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_satnav_obs._get_packed_fingerprint()
            )
            self.obs[i0]._encode_one(buf)
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert (
                self.integrity[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_integrity._get_packed_fingerprint()
            )
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_satnav._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_satnav._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_satnav()
        self.icd_measurement_satnav = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.receiver_clock_time = aspn23_lcm.type_satnav_time._decode_one(buf)
        self.num_signal_types, self.num_signals_tracked = struct.unpack(
            ">ii", buf.read(8)
        )
        self.obs = []
        for i0 in range(self.num_signals_tracked):
            self.obs.append(aspn23_lcm.type_satnav_obs._decode_one(buf))
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_satnav in parents:
            return 0
        newparents = parents + [measurement_satnav]
        tmphash = (
            0xABCF36ABA23E0FAF
            + aspn23_lcm.type_header._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_satnav_time._get_hash_recursive(newparents)
            + aspn23_lcm.type_satnav_obs._get_hash_recursive(newparents)
            + aspn23_lcm.type_integrity._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_satnav._packed_fingerprint is None:
            measurement_satnav._packed_fingerprint = struct.pack(
                ">Q", measurement_satnav._get_hash_recursive([])
            )
        return measurement_satnav._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", measurement_satnav._get_packed_fingerprint())[0]
