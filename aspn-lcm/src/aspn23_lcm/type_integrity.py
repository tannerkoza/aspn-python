"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

"""
This code is generated via https://git.aspn.us/pntos/firehose/-/blob/main/firehose/backends/aspn/aspn_yaml_to_lcm.py
DO NOT hand edit code.  Make any changes required using the firehose repo instead
"""

from io import BytesIO
import struct

class type_integrity(object):
    """
    Integrity provides a numerical measure of the trustworthiness of the associated measurement. The
    integrity_method enum specifies the integrity method and the appropriate interpretation of the
    integrity_value.
    """

    __slots__ = ["icd_type_integrity", "integrity_method", "integrity_value"]

    __typenames__ = ["int8_t", "int8_t", "double"]

    __dimensions__ = [None, None, None]

    def __init__(self):
        self.icd_type_integrity = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.integrity_method = 0
        """
        Enumerated field which describes the meaning of the integrity value. Integrity methods may use
        multiple enum entries if there is a need to pass multiple integrity values. For example, an
        integrity method with 3 parameters may use 3 enum entries (e.g., MY_METHOD_VALUE1, MY_METHOD_VALUE2,
        MY_METHOD_VALUE3). When integrity is reported in a message, a vector of integrity types is passed.
        In the MY_METHOD example, num_integrity = 3 just for the MY_METHOD integrity. If additional
        integrity methods are also reported, then num_integrity would be greater than 3 to include those
        additional methods.
        LCM Type: int8_t
        """

        self.integrity_value = 0.0
        """
        Description: Measurement integrity value to be interpreted based on the definition in the
        integrity_type enum.
        Units: none
        LCM Type: double
        """


    def encode(self):
        buf = BytesIO()
        buf.write(type_integrity._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">bbd", self.icd_type_integrity, self.integrity_method, self.integrity_value))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_integrity._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_integrity._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_integrity()
        self.icd_type_integrity, self.integrity_method, self.integrity_value = struct.unpack(">bbd", buf.read(10))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_integrity in parents: return 0
        tmphash = (0x6c4f1be7420b3c11) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_integrity._packed_fingerprint is None:
            type_integrity._packed_fingerprint = struct.pack(">Q", type_integrity._get_hash_recursive([]))
        return type_integrity._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", type_integrity._get_packed_fingerprint())[0]

