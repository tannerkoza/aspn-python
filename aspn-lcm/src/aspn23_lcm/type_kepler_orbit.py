"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

"""
This code is generated via https://git.aspn.us/pntos/firehose/-/blob/main/firehose/backends/aspn/aspn_yaml_to_lcm.py
DO NOT hand edit code.  Make any changes required using the firehose repo instead
"""

from io import BytesIO
import struct

class type_kepler_orbit(object):
    """ Keplerian orbit parameters required to calculate satellite position """

    __slots__ = ["icd_type_kepler_orbit", "m_0", "delta_n", "e", "sqrt_a", "omega_0", "i_0", "i_dot", "omega", "omega_dot", "c_uc", "c_us", "c_rc", "c_rs", "c_ic", "c_is", "t_oe"]

    __typenames__ = ["int8_t", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double", "double"]

    __dimensions__ = [None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None]

    def __init__(self):
        self.icd_type_kepler_orbit = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.m_0 = 0.0
        """
        Description: Mean anomaly at reference time.
        Units: rad
        LCM Type: double
        """

        self.delta_n = 0.0
        """
        Description: Mean motion difference from computed value.
        Units: rad/s
        LCM Type: double
        """

        self.e = 0.0
        """
        Description: Eccentricity.
        Units: none
        LCM Type: double
        """

        self.sqrt_a = 0.0
        """
        Description: Square root of semi-major axis.
        Units: sqrt(m)
        LCM Type: double
        """

        self.omega_0 = 0.0
        """
        Description: Longitude of ascending node of orbit plane at weekly epoch
        Units: rad
        LCM Type: double
        """

        self.i_0 = 0.0
        """
        Description: Inclination angle at reference time.
        Units: rad
        LCM Type: double
        """

        self.i_dot = 0.0
        """
        Description: Rate of change of inclination angle.
        Units: rad
        LCM Type: double
        """

        self.omega = 0.0
        """
        Description: Argument of perigee.
        Units: rad
        LCM Type: double
        """

        self.omega_dot = 0.0
        """
        Description: Rate of right ascension.
        Units: rad/s
        LCM Type: double
        """

        self.c_uc = 0.0
        """
        Description: Amplitude of cosine harmonic correction terms to the argument of latitude.
        Units: rad
        LCM Type: double
        """

        self.c_us = 0.0
        """
        Description: Amplitude of sine harmonic correction terms to the argument of latitude.
        Units: rad
        LCM Type: double
        """

        self.c_rc = 0.0
        """
        Description: Amplitude of cosine harmonic correction terms to the orbit radius.
        Units: m
        LCM Type: double
        """

        self.c_rs = 0.0
        """
        Description: Amplitude of sine harmonic correction terms to the orbit radius.
        Units: m
        LCM Type: double
        """

        self.c_ic = 0.0
        """
        Description: Amplitude of cosine harmonic correction terms to the angle of inclination.
        Units: rad
        LCM Type: double
        """

        self.c_is = 0.0
        """
        Description: Amplitude of sine harmonic correction terms to the angle of inclination.
        Units: rad
        LCM Type: double
        """

        self.t_oe = 0.0
        """
        Description: Ephemeris reference time.
        Units: s
        LCM Type: double
        """


    def encode(self):
        buf = BytesIO()
        buf.write(type_kepler_orbit._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">bdddddddddddddddd", self.icd_type_kepler_orbit, self.m_0, self.delta_n, self.e, self.sqrt_a, self.omega_0, self.i_0, self.i_dot, self.omega, self.omega_dot, self.c_uc, self.c_us, self.c_rc, self.c_rs, self.c_ic, self.c_is, self.t_oe))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_kepler_orbit._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_kepler_orbit._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_kepler_orbit()
        self.icd_type_kepler_orbit, self.m_0, self.delta_n, self.e, self.sqrt_a, self.omega_0, self.i_0, self.i_dot, self.omega, self.omega_dot, self.c_uc, self.c_us, self.c_rc, self.c_rs, self.c_ic, self.c_is, self.t_oe = struct.unpack(">bdddddddddddddddd", buf.read(129))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_kepler_orbit in parents: return 0
        tmphash = (0xab17ef7ace772aff) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_kepler_orbit._packed_fingerprint is None:
            type_kepler_orbit._packed_fingerprint = struct.pack(">Q", type_kepler_orbit._get_hash_recursive([]))
        return type_kepler_orbit._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", type_kepler_orbit._get_packed_fingerprint())[0]

