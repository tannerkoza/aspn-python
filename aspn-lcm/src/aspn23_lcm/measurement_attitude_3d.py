"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

from io import BytesIO
import struct

import aspn23_lcm


class measurement_attitude_3d(object):
    """
    Three-dimensional attitude expressed as a quaternion, a four element vector
    representation, the elements of which are functions of the orientation of the
    vector and the magnitude of the rotation.
    """

    __slots__ = [
        "icd_measurement_attitude_3d",
        "header",
        "time_of_validity",
        "reference_frame",
        "quaternion",
        "tilt_error_covariance",
        "error_model",
        "num_error_model_params",
        "error_model_params",
        "num_integrity",
        "integrity",
    ]

    __typenames__ = [
        "int8_t",
        "aspn23_lcm.type_header",
        "aspn23_lcm.type_timestamp",
        "int8_t",
        "double",
        "double",
        "int8_t",
        "int32_t",
        "double",
        "int16_t",
        "aspn23_lcm.type_integrity",
    ]

    __dimensions__ = [
        None,
        None,
        None,
        None,
        [4],
        [3, 3],
        None,
        None,
        ["num_error_model_params"],
        None,
        ["num_integrity"],
    ]

    REFERENCE_FRAME_ECI = 0
    """ Absolute inertial attitude. Sensor frame attitude relative to the earth-centered, inertial (ECi) frame. See also ECi coordinate frame definition for x, y, and z definitions. """
    REFERENCE_FRAME_ECEF = 1
    """ Attitude relative to Earth. Sensor frame attitude relative to the ECEF frame. Generally, time is required to convert between absolute inertial attitude and attitude relative to Earth. See also ECEF coordinate frame definition for x, y, and z definitions. """
    REFERENCE_FRAME_NED = 2
    """ Local level, geographic attitude. Sensor frame attitude with respect to earth-fixed frame expressed in the North-East-Down (NED), local level frame. See also NED coordinate frame definition for N, E, and D definitions. Generally, position is required to convert between attitude relative to the earth and locally level, geographic attitude. See also NED coordinate frame definition for N, E, and D definitions. """
    ERROR_MODEL_NONE = 0
    """ No additional error model provided (num_error_model_params = 0). """

    def __init__(self):
        self.icd_measurement_attitude_3d = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.header = aspn23_lcm.type_header()
        """
        Description: Standard ASPN measurement header
        Units: none
        LCM Type: aspn23_lcm.type_header
        """

        self.time_of_validity = aspn23_lcm.type_timestamp()
        """
        Description: Time at which the measurement is considered to be valid 
        Units: none
        LCM Type: aspn23_lcm.type_timestamp
        """

        self.reference_frame = 0
        """
        Defines measurement reference.
        LCM Type: int8_t
        """

        self.quaternion = [0.0 for dim0 in range(4)]
        """
        Description: Four element quaternion, q = [a, b, c, d], where a = cos(phi/2), b = (phi_x/phi)*sin(phi/2), c = (phi_y/phi)*sin(phi/2), and d = (phi_z/phi)*sin(phi/2). In this description, the vector [phi_x, phi_y, phi_z] represents the rotation vector that describes the frame rotation to be applied to the "reference" frame (ECI, ECEF, or NED) to rotate it into the axes that describe the measured attitude, and the value phi is the magnitude of the [phi_x, phi_y, phi_z] vector. See "conventions" documentation for more detailed information
        Units: none
        LCM Type: double[4]
        """

        self.tilt_error_covariance = [[0.0 for dim1 in range(3)] for dim0 in range(3)]
        """
        Description: Tilt error covariance matrix. This matrix represents the uncertainty in the "tilt errors" that represent the additional rotation to be applied to the provided attitude quaternion in order to convert it to the true attitude with no errors. By convention, these "tilt errors" are expressed in the reference frame (ECI, ECEF, or NED). See "conventions" documentation for more detailed information
        Units: rad^2
        LCM Type: double[3][3]
        """

        self.error_model = 0
        """
        Defines an optional error model for other than zero-mean, additive, white Gaussian noise (AWGN).
        LCM Type: int8_t
        """

        self.num_error_model_params = 0
        """
        Description: Number of parameters required for the error model chosen
        Units: none
        LCM Type: int32_t
        """

        self.error_model_params = []
        """
        Description: Error model parameters that characterize the optional error model
        Units: various
        LCM Type: double[num_error_model_params]
        """

        self.num_integrity = 0
        """
        Description: Number of integrity values
        Units: none
        LCM Type: int16_t
        """

        self.integrity = []
        """
        Description: Measurement integrity. Includes the integrity method used and an integrity value (which is to be interpreted based upon the integrity method). The intent of allowing num_integrity > 1 is to report multiple integrity values based on multiple integrity methods
        Units: none
        LCM Type: aspn23_lcm.type_integrity[num_integrity]
        """

    def encode(self):
        buf = BytesIO()
        buf.write(measurement_attitude_3d._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">b", self.icd_measurement_attitude_3d))
        assert (
            self.header._get_packed_fingerprint()
            == aspn23_lcm.type_header._get_packed_fingerprint()
        )
        self.header._encode_one(buf)
        assert (
            self.time_of_validity._get_packed_fingerprint()
            == aspn23_lcm.type_timestamp._get_packed_fingerprint()
        )
        self.time_of_validity._encode_one(buf)
        buf.write(struct.pack(">b", self.reference_frame))
        buf.write(struct.pack(">4d", *self.quaternion[:4]))
        for i0 in range(3):
            buf.write(struct.pack(">3d", *self.tilt_error_covariance[i0][:3]))
        buf.write(struct.pack(">bi", self.error_model, self.num_error_model_params))
        buf.write(
            struct.pack(
                ">%dd" % self.num_error_model_params,
                *self.error_model_params[: self.num_error_model_params]
            )
        )
        buf.write(struct.pack(">h", self.num_integrity))
        for i0 in range(self.num_integrity):
            assert (
                self.integrity[i0]._get_packed_fingerprint()
                == aspn23_lcm.type_integrity._get_packed_fingerprint()
            )
            self.integrity[i0]._encode_one(buf)

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, "read"):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != measurement_attitude_3d._get_packed_fingerprint():
            raise ValueError("Decode error")
        return measurement_attitude_3d._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = measurement_attitude_3d()
        self.icd_measurement_attitude_3d = struct.unpack(">b", buf.read(1))[0]
        self.header = aspn23_lcm.type_header._decode_one(buf)
        self.time_of_validity = aspn23_lcm.type_timestamp._decode_one(buf)
        self.reference_frame = struct.unpack(">b", buf.read(1))[0]
        self.quaternion = struct.unpack(">4d", buf.read(32))
        self.tilt_error_covariance = []
        for i0 in range(3):
            self.tilt_error_covariance.append(struct.unpack(">3d", buf.read(24)))
        self.error_model, self.num_error_model_params = struct.unpack(
            ">bi", buf.read(5)
        )
        self.error_model_params = struct.unpack(
            ">%dd" % self.num_error_model_params,
            buf.read(self.num_error_model_params * 8),
        )
        self.num_integrity = struct.unpack(">h", buf.read(2))[0]
        self.integrity = []
        for i0 in range(self.num_integrity):
            self.integrity.append(aspn23_lcm.type_integrity._decode_one(buf))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if measurement_attitude_3d in parents:
            return 0
        newparents = parents + [measurement_attitude_3d]
        tmphash = (
            0x2AD08882568B8806
            + aspn23_lcm.type_header._get_hash_recursive(newparents)
            + aspn23_lcm.type_timestamp._get_hash_recursive(newparents)
            + aspn23_lcm.type_integrity._get_hash_recursive(newparents)
        ) & 0xFFFFFFFFFFFFFFFF
        tmphash = (
            ((tmphash << 1) & 0xFFFFFFFFFFFFFFFF) + (tmphash >> 63)
        ) & 0xFFFFFFFFFFFFFFFF
        return tmphash

    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if measurement_attitude_3d._packed_fingerprint is None:
            measurement_attitude_3d._packed_fingerprint = struct.pack(
                ">Q", measurement_attitude_3d._get_hash_recursive([])
            )
        return measurement_attitude_3d._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", measurement_attitude_3d._get_packed_fingerprint())[0]
