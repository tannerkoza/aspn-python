"""LCM type definitions
This file automatically generated by lcm.
DO NOT MODIFY BY HAND!!!!
"""

"""
This code is generated via https://git.aspn.us/pntos/firehose/-/blob/main/firehose/backends/aspn/aspn_yaml_to_lcm.py
DO NOT hand edit code.  Make any changes required using the firehose repo instead
"""

from io import BytesIO
import struct

class type_header(object):
    """ Header for each ASPN measurement """

    __slots__ = ["icd_type_header", "vendor_id", "device_id", "context_id", "sequence_id"]

    __typenames__ = ["int8_t", "int64_t", "int64_t", "int64_t", "int32_t"]

    __dimensions__ = [None, None, None, None, None]

    def __init__(self):
        self.icd_type_header = 0
        """
        Non ASPN. Do not use. Extra field encoding the struct name to disambiguate LCM type fingerprint hashes.
        LCM Type: int8_t
        """

        self.vendor_id = 0
        """
        Description: Unique identifier that identifies the device or application vendor. Vendor ID is
        user-selected, inspired by your company name to mitigate conflicts with other users. Vendor IDs 0x23
        00 00 00 through 0x23 FF FF FF inclusive are reserved and shall not be chosen as user-selected
        vendor IDs.
        Units: none
        LCM Type: int64_t
        """

        self.device_id = 0
        """
        Description: Unique identifier that identifies the sensor or device type as assigned by the
        vendor. Device_ids are unique within a given vendor_id.
        Units: none
        LCM Type: int64_t
        """

        self.context_id = 0
        """
        Description: Unique identifier that provides additional context to define a logical stream of
        data from the sensor or device as assigned by the vendor. This identifier allows multiple
        measurements of the same type to be provided by a device. Context_ids are unique within a given
        vendor_id and device_id.
        Units: none
        LCM Type: int64_t
        """

        self.sequence_id = 0
        """
        Description: Unique identifier for a specific message within a data stream as defined by a
        vendor_id, device_id, and context_id. Sequential messages from each data source (identified by
        vendor_id, device_id, and context_id) shall increment by exactly 1 and rollover to 0 after an
        overflow.
        Units: none
        LCM Type: int32_t
        """


    def encode(self):
        buf = BytesIO()
        buf.write(type_header._get_packed_fingerprint())
        self._encode_one(buf)
        return buf.getvalue()

    def _encode_one(self, buf):
        buf.write(struct.pack(">bqqqi", self.icd_type_header, self.vendor_id, self.device_id, self.context_id, self.sequence_id))

    @staticmethod
    def decode(data: bytes):
        if hasattr(data, 'read'):
            buf = data
        else:
            buf = BytesIO(data)
        if buf.read(8) != type_header._get_packed_fingerprint():
            raise ValueError("Decode error")
        return type_header._decode_one(buf)

    @staticmethod
    def _decode_one(buf):
        self = type_header()
        self.icd_type_header, self.vendor_id, self.device_id, self.context_id, self.sequence_id = struct.unpack(">bqqqi", buf.read(29))
        return self

    @staticmethod
    def _get_hash_recursive(parents):
        if type_header in parents: return 0
        tmphash = (0xfdde0d3af6218fb2) & 0xffffffffffffffff
        tmphash  = (((tmphash<<1)&0xffffffffffffffff) + (tmphash>>63)) & 0xffffffffffffffff
        return tmphash
    _packed_fingerprint = None

    @staticmethod
    def _get_packed_fingerprint():
        if type_header._packed_fingerprint is None:
            type_header._packed_fingerprint = struct.pack(">Q", type_header._get_hash_recursive([]))
        return type_header._packed_fingerprint

    def get_hash(self):
        """Get the LCM hash of the struct"""
        return struct.unpack(">Q", type_header._get_packed_fingerprint())[0]

